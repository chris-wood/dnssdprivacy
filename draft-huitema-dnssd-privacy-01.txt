


Network Working Group                                         C. Huitema
Internet-Draft                                                 Microsoft
Intended status: Standards Track                               D. Kaiser
Expires: December 2, 2016                         University of Konstanz
                                                            May 31, 2016


                     Privacy Extensions for DNS-SD
                   draft-huitema-dnssd-privacy-01.txt

Abstract

   DNS-SD allows discovery of services published in DNS or MDNS.  The
   publication normally disclose information about the device publishing
   the services.  There are use cases where devices want to communicate
   without disclosing their identity, for example two mobile devices
   visiting the same hotspot.  We propose a method to obfuscate the
   identification information published by DNS-SD.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on December 2, 2016.

Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of



Huitema & Kaiser        Expires December 2, 2016                [Page 1]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Requirements  . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Privacy implications of DNS-SD  . . . . . . . . . . . . . . .   3
     2.1.  Privacy implication of publishing Service Instance Names    4
     2.2.  Privacy implication of publishing node names  . . . . . .   4
     2.3.  Privacy implication of publishing service attributes  . .   5
     2.4.  Device fingerprinting . . . . . . . . . . . . . . . . . .   5
     2.5.  Privacy implication of discovering services . . . . . . .   6
   3.  Design of DNS-SD privacy mitigations  . . . . . . . . . . . .   6
     3.1.  Device Pairing  . . . . . . . . . . . . . . . . . . . . .   6
     3.2.  Obfuscated instance names . . . . . . . . . . . . . . . .   7
     3.3.  Names of obfuscated services  . . . . . . . . . . . . . .   8
     3.4.  Scaling issues with obfuscation . . . . . . . . . . . . .   9
     3.5.  Private Service Directory Service . . . . . . . . . . . .  10
     3.6.  Directed Private Discovery  . . . . . . . . . . . . . . .  12
     3.7.  Randomized host names . . . . . . . . . . . . . . . . . .  12
     3.8.  Timing of obfuscation and randomization . . . . . . . . .  12
     3.9.  A note on Private DNS services  . . . . . . . . . . . . .  13
   4.  Privacy extensions for DNS-SD . . . . . . . . . . . . . . . .  13
     4.1.  Randomized Host Name  . . . . . . . . . . . . . . . . . .  14
     4.2.  Instance Discovery Key  . . . . . . . . . . . . . . . . .  14
     4.3.  Composing Obfuscated Instance Names . . . . . . . . . . .  14
     4.4.  De-Obfuscation of Instance Names  . . . . . . . . . . . .  15
   5.  Considerations on the pairing requirement . . . . . . . . . .  16
     5.1.  Device Pairing  . . . . . . . . . . . . . . . . . . . . .  16
     5.2.  Directory Discovery . . . . . . . . . . . . . . . . . . .  17
     5.3.  Service Querying  . . . . . . . . . . . . . . . . . . . .  18
     5.4.  Summarizing Thoughts  . . . . . . . . . . . . . . . . . .  18
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  18
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  19
   8.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  19
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  19
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  19
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  19
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  21

1.  Introduction

   DNS-SD [RFC6763] enables distribution and discovery in local networks
   without configuration.  It is very convenient for users, but it
   requires the public exposure of the offering and requesting
   identities along with information about the offered and requested
   services.  Some of the information published by the announcements can



Huitema & Kaiser        Expires December 2, 2016                [Page 2]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   be very revealing.  These privacy issues and potential solutions are
   discussed in [KW14a] and [KW14b].

   There are cases when nodes connected to a network want to provide or
   consume services without exposing their identity to the other parties
   connected to the same network.  Consider for example a traveler
   wanting to upload pictures from a phone to a laptop when connected to
   the Wi-Fi network of an Internet cafe, or two travelers who want to
   share files between their laptops when waiting for their plane in an
   airport lounge.

   We expect that these exchanges will start with a discovery procedure
   using DNS-SD [RFC6763].  One of the devices will publish the
   availability of a service, such as a picture library or a file store
   in our examples.  The user of the other device will discover this
   service, and then connect to it.

   When analyzing these scenarios in Section 2, we find that the DNS-SD
   messages leak identifying information such as instance name, host
   name or service properties.  We review the design constraint of a
   solution in Section 3, and describe the proposed solution in
   Section 4.

1.1.  Requirements

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

2.  Privacy implications of DNS-SD

   DNS-Based Service Discovery (DNS-SD) is defined in [RFC6763].  It
   allows nodes to publish the availability of an instance of a service
   by inserting specific records in the DNS ([RFC1033], [RFC1034],
   [RFC1035]) or by publishing these records locally using multicast DNS
   (mDNS) [RFC6762].  Available services are described using three types
   of records:

   PTR Record:  Associates a service type in the domain with an
      "instance" name of this service type.

   SRV Record:  Provides the node name, port number, priority and weight
      associated with the service instance, in conformance with
      [RFC2782].

   TXT Record:  Provides a set of attribute-value pairs describing
      specific properties of the service instance.




Huitema & Kaiser        Expires December 2, 2016                [Page 3]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   In the remaining subsections, we will review the privacy issues
   related to publishing instance names, node names, service attributes
   and other data, as well as review the implications of using the
   discovery service as a client.

2.1.  Privacy implication of publishing Service Instance Names

   In the first phase of discovery, the client obtains all the PTR
   records associated with a service type in a given naming domain.
   Each PTR record contains a Service Instance Name defined in Section 4
   of [RFC6763]:

     Service Instance Name = <Instance> . <Service> . <Domain>

   The <Instance> portion of the Service Instance Name is meant to
   convey enough information for users of discovery clients to easily
   select the desired service instance.  Nodes that use DNS-SD over mDNS
   [RFC6762] in a mobile environment will rely on the specificity of the
   instance name to identify the desired service instance.  In our
   example of users wanting to upload pictures to a laptop in an
   Internet Cafe, the list of available service instances may look like:

   Alice's Images         . _imageStore._tcp . local
   Alice's Mobile Phone   . _presence._tcp   . local
   Alice's Notebook       . _presence._tcp   . local
   Bob's Notebook         . _presence._tcp   . local
   Carol's Notebook       . _presence._tcp   . local

   Alice will see the list on her phone and understand intuitively that
   she should pick the fist item.  The discovery will "just work".

   However, DNS-SD/mDNS will reveal to anybody that Alice is currently
   visiting the Internet Cafe.  It further discloses the fact that she
   uses two devices, shares an image store, and uses a chat application
   supporting the _presence protocol on both of her devices.  She might
   currently chat with Bob or Carol, as they are also using a _presence
   supporting chat application.  This information is not just available
   to devices actively browsing for and offering services, but to
   anybody passively listing to the network traffic.

2.2.  Privacy implication of publishing node names

   The SRV records contain the DNS name of the node publishing the
   service.  Typical implementations construct this DNS name by
   concatenating the "host name" of the node with the name of the local
   domain.  The privacy implications of this practice are reviewed in
   [I-D.ietf-intarea-hostname-practice].  Depending on naming practices,
   the host name is either a strong identifier of the device, or at a



Huitema & Kaiser        Expires December 2, 2016                [Page 4]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   minimum a partial identifier.  It enables tracking of the device, and
   by extension of the device's owner.

2.3.  Privacy implication of publishing service attributes

   The TXT records contain a set of attribute and value pairs
   characteristics of the service implementation.  These attributes
   reveal some information about the devices that publishes the service.
   The amount of information will vary widely with the particular
   service and its implementation:

   o  Some attributes like the paper size available in a printer, are
      the same on many devices, and thus only provides limited
      information to a tracker.

   o  Attributes that have freeform values, such as the name of a
      directory, may reveal much more information.

   Combinations of attributes have more information power than specific
   attributes, and can potentially be used for "fingerprinting" a
   specific device.

2.4.  Device fingerprinting

   The combination of information published in DNS-SD has the potential
   to provide a "fingerprint" of a specific device.  Such information
   includes:

   o  The list of services published by the device, which can be
      retrieved because the SRV records will point to the same host
      name.

   o  The specific attributes describing these services.

   o  The port numbers used by the services.

   o  The values of the priority and weight attributes in the SRV
      records.

   This combination of services and attribute will often be sufficient
   to identify the version of the software running on a device.  If a
   device publishes many services with rich sets of attributes, the
   combination may be sufficient to identify the specific device.

   There is however an argument that devices providing services can be
   discovered by observing the local traffic, because different services
   have different traffic patterns.  The observation could in many cases
   also reveal some specificities of the service's implementation.  Even



Huitema & Kaiser        Expires December 2, 2016                [Page 5]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   if the traffic is encrypted, the size and the timing of packets may
   be sufficient to reveal that information.  This argument can be used
   to assess the priority of, for example, protecting the fact that a
   device publishes a particular service.  However, we may assume that
   the developers of sensitive services will use counter-measures to
   defeat such traffic analysis.

2.5.  Privacy implication of discovering services

   The consumers of services engage in discovery, and in doing so do
   reveal some information such as the list of services that they are
   interested in and the domains in which they are looking for the
   services.  When the clients select specific instances of services,
   they reveal their preference for these instances.  This can be benign
   if the service type is very common, but it could be more problematic
   for sensitive services, such as for example some private messaging
   services.

   One way to protect clients would be to somehow encrypt the requested
   service types.  Of course, just as we noted in Section 2.4, traffic
   analysis can often reveal the service.

3.  Design of DNS-SD privacy mitigations

   In this section, we present the design of the privacy mitigations.

   Privacy Preserving Service Discovery can be divided into three
   independent layers: Device Pairing, Directory Discovery, and Service
   Querying [KW14b].

3.1.  Device Pairing

   Any private discovery solution will need to understand which
   differentiate between authorized devices, for which the discovery
   will be successful, and other devices, which should not be aware of
   the availability of the service.  The commonly used solution to this
   problem is to establish "device pairing."  In our discovery
   scenarios, we envisage two kinds of pairings:

   1.  inter-user pairing is a pairing between devices of "friends".
       Since this has to be done manually, e.g. by the means described
       above, it is important to limit it to once per pair of friends.

   2.  intra-user pairing is a pairing of devices of the same user.  It
       can be performed without any configuration by a meta-service
       (pairing data synchronization service) in a trusted (home)
       network.




Huitema & Kaiser        Expires December 2, 2016                [Page 6]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   The result of the pairing will normally be the exchange of a shared
   secret between the devices, or the addition of the devices public
   keys to a local web of trust.  Public key technology has many
   advatanges, but shared secrets are typically easier to handle on
   small devices.

3.2.  Obfuscated instance names

   The privacy issues described in Section 2.1 can be solved by
   obfuscating the instance names.  Instead of a user friendly
   description of the instance, the nodes will publish a random looking
   string of characters.  To prevent tracking over time and location,
   different string values should be used at different locations, or at
   different times.

   Authorized parties should be able to "de-obfuscate" the names, while
   non-authorized third parties will not be.  For example, if both Alice
   notebook and Bob's laptop use an obfuscation process, the list of
   available services should appear differently to them and to third
   parties.  Alice's phone will be able to de-obfuscate the name of
   Alice's notebook, but not that of Bob's laptop.  Bob's phone will do
   the opposite.  Carol will do neither.

   Alice will see something like:

   QwertyUiopAsdfghjk (Alice's Images)       . _imageStore._tcp . local
   GobbeldygookBlaBla (Alice's Mobile Phone) . _presence._tcp   . local
   MNbvCxzLkjhGfdEdhg (Alice's Notebook)     . _presence._tcp   . local
   Abracadabragooklybok (Bob's Notebook)     . _presence._tcp   . local
   Carol's Notebook                          . _presence._tcp   . local

   Bob will see:

   QwertyUiopAsdfghjk                    . _imageStore._tcp . local
   GobbeldygookBlaBla                    . _presence._tcp   . local
   MNbvCxzLkjhGfdEdhg                    . _presence._tcp   . local
   Abracadabragooklybok (Bob's Notebook) . _presence._tcp   . local
   Carol's Notebook                      . _presence._tcp   . local

   Carol will see:

   QwertyUiopAsdfghjk   . _imageStore._tcp . local
   GobbeldygookBlaBla   . _presence._tcp   . local
   MNbvCxzLkjhGfdEdhg   . _presence._tcp   . local
   Abracadabragooklybok . _presence._tcp   . local
   Carol's Notebook     . _presence._tcp   . local





Huitema & Kaiser        Expires December 2, 2016                [Page 7]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   In that example, Alice, Bob and Carol will be able to select the
   appropriate instance.  It would probably be preferable to filter out
   the obfuscated instance names, to avoid confusing the user.  In our
   example, Alice and Bob have updated their software to understand
   obfuscation, and they could easily filter out the obfuscated strings
   that they do not like.  But Carol is not using this system, and we
   could argue that her experience is suboptimal.

   The suboptimal experience with unmodified software could be avoided
   if the obfuscated service records were published using different
   service names, or using different domain names.  This would of course
   make management a bit more complex, and is thus debatable.

3.3.  Names of obfuscated services

   Instead of publishing the actual service name in the SRV records,
   nodes could publish a randomized name.  There are two plausible
   reasons for doing that:

   o  Having a different service name for privacy enhanced services will
      ensure that hosts that are not privacy aware are not puzzled by
      obfuscated service names.

   o  Using obfuscated service names prevents third parties from
      discovering which service a particular host is providing or
      consuming.

   The first requirement can be met with a simple modification of an
   existing name.  For example, instead of publishing:

   QwertyUiopAsdfghjk . _imageStore._tcp . local
   GobbeldygookBlaBla . _presence._tcp   . local

   Alice could publish some kind of "translation" of the service name,
   such as:

   QwertyUiopAsdfghjk . _vzntrFgber._tcp . local
   GobbeldygookBlaBla . _cerfrapr._tcp   . local

   The previous examples use rot13 translation.  It does not provide any
   particular privacy, but it does ensure that obfuscated services are
   named differently from clear text services.

   Making the service name actually private would require some actual
   encryption.  The main problem with such solutions is that the client
   needs to know the service name in order to compose the DNS-SD query
   for services.  There are several options:




Huitema & Kaiser        Expires December 2, 2016                [Page 8]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   o  The service name is chosen by the client.  For example, the client
      could encrypt the original service name and a nonce with a key
      shared between client and server.  Upon receiving the queries, the
      server would attempt to decrypt the service name.  If that
      succeeds, the server would respond with PTR records created on the
      fly for the new service name.

   o  The service name is chosen by the server and cannot be predicted
      in advance by the client.  For example, the server could encrypt a
      nonce and the original service name.  The client retrieves such
      services by doing a wild card query, then attempting to decrypt
      the received responses.

   o  The service name is chosen by the server in a way that can be
      predicted in advance by the client.  For example, the server could
      encrypt some version of the data and time and the original service
      name.  The data and time are encoded with a coarse precision,
      enabling the client to predict the value that the server is using,
      and to send the corresponding queries.

   None of these solutions is very attractive.  Creating records on the
   fly is a burden for the server.  If clients must use wildcard
   queries, they will need to process lots of irrelevant data.  If
   clients need to predict different instance names for each potential
   server, they will end up sending batches of queries with many
   different names.  All of these solutions appear like big departures
   from the simplicity and robustness of the DNS-SD design.

   Given the relatively low priority of hiding the service name and the
   complexity of the potential solutions, we are not recommending any
   particular protection for the instance names.

3.4.  Scaling issues with obfuscation

   In Section 3.2, we assumed that each advertised record contains a
   name obfuscated with a shared key.  This approach is easy to
   understand, but it contains the hidden assumption.  Let look at one
   of our examples:

   Abracadabragooklybok (Bob's Notebook) . _presence._tcp   . local

   We only see there one record for Bob's Notebook, obfuscated using the
   unique shared secret associated with Bob's Notebook.  That means that
   every device paired with Bob's Notebook will have a copy of that
   shared secret.  We could of course do that, but there are known
   issues with having a secret shared with multiple entities:





Huitema & Kaiser        Expires December 2, 2016                [Page 9]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   o  If for some reason the secret needs to be changed, every paired
      device will need a copy of the new secret before they can
      participate again in discovery;

   o  If one of the previous pairing becomes invalid, the only way to
      block the corresponding devices from discovery is to change the
      secret for all other devices.

   Key management becomes much easier if it is strictly pair-wise.  Two
   paired devices, or to pairs of users, can simply renew their pairing
   and get a new secret.  If a device ceases to be trusted, the pairing
   data and the corresponding secret can just be deleted and forgotten.
   But then, we have a scaling issue.  Let's assume that:

   o  Each device maintains an average of N pairing

   o  There are on average M devices present during discovery

   In the single key scenario, after issuing a broadcast query, the
   querier will receive a series of responses, each of which may well be
   obfuscated with a different key.  If the receiver has N pre-existing
   pairing and receives M obfuscated responses, the cost will scale as
   O(M*N), i.e. try all N pairing keys for each of the M responses to
   see what matches.  But if the keys are specific to each pair of
   devices, the obfuscation becomes complicated.  When receiving a
   request, the publisher does not know which of its N keys the querier
   can decrypt.  One simple solution would be to send N responses, but
   then the load on the querier will scale as O(M*N^2).  That can go out
   of hand very quickly.

   To solve the scaling issue, we consider a two-stages solutions: use
   an optimized discovery procedure to discover privacy-compatible
   devices; and use point to point encrypted exchanges to privately
   discover the available services.

3.5.  Private Service Directory Service

   The first step of the two-stage solution is the discovery of the
   available "privacy compatible" devices.  The goal of that stage is to
   identify devices that share a pairing with the querier, and are
   available locally.  They could be discovered by querying for the
   service "_psds._tls" using regular DNS-SD procedures, but the list of
   discovered services will have to be filtered so only paired devices
   are retained.

   We have demonstrated in Section 3.4 that simple obfuscation would
   require publishing as many records per publsiher as they are pairing,
   which ends up scaling as O(M*N^2) in which M is the number of devices



Huitema & Kaiser        Expires December 2, 2016               [Page 10]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   present and N is the number of pairing pr device.  We can mitigate
   this problem by using a special encoding of the instance name.
   Suppose that the publisher manages N pairings with the associated
   keys K1, K2, ... Kn.  The instance name will be set to an encoding of
   N "proofs" of the N keys, where each proof is computed as function of
   the key and a nonce:

      instance name = <nonce><F1><F2>..<Fn>

      Fi = hash (nonce, Ki), where hash is a cryptographic hash
      function.

   The querier can test the instance name by computing the same "proof"
   for each of its own keys.  Suppose that the receiver manages P
   pairings, with the corresponding keys X1, X2, .. Xp.  The receiver
   verification procedure will be:

      for each received instance name:
         retrieve nonce from instance name
         for (j = 1 to P)
            retrieve the key Xj of pairing number j
            compute F = hash(nonce, Xj)
            for (i=1 to N)
               retrieve the proof Fi
               if F is equal to Fi
                  mark the pairing number j as available

   The procedure presented here requires on average O(M*N) iterations of
   the hash function, which is the same scaling as the "shared secret"
   variant.  It requires O(M*N^2) comparison operations, but these are
   less onerous than operation operations.

   The number of pairing proofs that can be encoded in a single record
   is limited by the maximum size of a DNS label, which is 63 bytes.
   Since this are characters and not pure binary values, nonce and
   proofs will have to be encoded using BASE64 ([RFC2045] section 6.8),
   resulting in at most 378 bits.  The nonce should not be repeated, and
   the simplest way to achieve that is to set the nonce to a 32 bit
   timestamp value.  The remaining 346 bits could encode up to 10 proofs
   of 32 bits each, which would be sufficient for many practical
   scenarios.

   In practice, a 32 bit proof should be sufficient to distinguish
   between avaliable devices.  However, there is clearly a risk of
   collision.  The privacy discovery service as described here will find
   the available pairings, but it might also find a spurious number of
   "false positives."  The chances of that happening are however quite




Huitema & Kaiser        Expires December 2, 2016               [Page 11]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   small: less than 0.02% for a device managing 10 pairings and
   processing 10000 responses.

3.6.  Directed Private Discovery

   The Private Service Directory Service discovery will allow a device
   to discover a list available paired devices, and to identify the
   corresponding pairing key.  At that point, the querier can engae in a
   series of directed discoveries.

   We are considering two options for the directed discoveries:

   1.  Use a unicast version of the DNS-SD service, in which the querier
       send a unicast DNS-SD query to each privately discovered Private
       Service Directory Server, looking for a service name ofbfuscated
       with the selected pairing key, and retrievig an obfuscated
       instance name,

   2.  Establish an encrypted connection with each discovered server,
       using for example a variation of TLS secured with the pairing
       key, and then send DNS-SD discovery requests over that
       connection.

3.7.  Randomized host names

   Instead of publishing their actual name in the SRV records, nodes
   could publish a randomized name.  That is the solution argued for in
   [I-D.ietf-intarea-hostname-practice].

   Randomized host names will prevent some of the tracking.  Host names
   are typically not visible by the users, and randomizing host names
   will probably not cause much usability issues.

3.8.  Timing of obfuscation and randomization

   It is important that the obfuscation of instance names is performed
   at the right time, and that the obfuscated names change in synchrony
   with other identifiers, such as MAC Addresses, IP Addresses or host
   names.  If the randomized host name changed but the instance name
   remained constant, an adversary would have no difficulty linking the
   old and new host names.  Similarly, if IP or MAC addresses changed
   but host names remained constant, the adversary could link the new
   addresses to the old ones using the published name.

   The problem is handled in [I-D.ietf-intarea-hostname-practice], which
   recommends to pick a new random host name at the time of connecting
   to a new network.  The instance names should be obfuscated at the




Huitema & Kaiser        Expires December 2, 2016               [Page 12]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   same time, or maybe use the randomized host name as input in the
   randomization process.

3.9.  A note on Private DNS services

   The DNS Private Exchange working group develops mechanisms to provide
   confidentiality to DNS transactions, addressing the problems outlined
   in [RFC7626].  The solutions being developed include DNS over TLS
   [RFC7858] and DNS over DTLS [I-D.ietf-dprive-dnsodtls].

   We could imagine that DNS-SD nodes are configured to update and
   retrieve DNS records using DNS over TLS or DNS over DTLS, but a
   number of problems can arise:

   o  Discovery queries are scoped by the domain name within which
      services are published.  As nodes move and visit arbitrary
      networks, there is no guarantee that the domain services for these
      networks will be accessible using DNS over TLS or DNS over DTLS.

   o  Information placed in the DNS is considered public.  Even if the
      server does support DNS over TLS, third parties will still be able
      to discover the content of PTR, SRV and TXT records.

   o  Neither DNS over TLS nor DNS over DTLS applies to MDNS.

   In short, DNS over TLS and DNS over DTLS solve a different problem,
   and are not a solution for DNS-SD privacy.

4.  Privacy extensions for DNS-SD

   The proposed solution uses the following components:

   o  The host names are randomized to prevent tracking.

   o  Nodes provide an Instance Discovery Key to other nodes authorized
      to discover the service instance.

   o  The Instance Discovery Key is combined with a random seed to
      obfuscate the instance names.

   o  Nodes engaged in discovery attempt to de-obfuscate the instance
      names using the set of Instance Discovery Keys that they know
      about.

   These components are detailed in the following subsections.






Huitema & Kaiser        Expires December 2, 2016               [Page 13]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


4.1.  Randomized Host Name

   Nodes publishing services with DNS-SD and concerned about their
   privacy MUST use a randomized host name.  The randomized name MUST be
   changed when network connectivity changes, to avid the correlation
   issues described in Section 3.8.  The randomized host name MUST be
   used in the SRV records describing the service instance, and the
   corresponding A or AAAA records MUST be made available through DNS or
   MDNS, within the same scope as the PTR, SRV and TXT records used by
   DNS-SD.

   If the link-layer address of the network connection is properly
   obfuscated (e.g. using MAC Address Randomization), The Randomized
   Host Name MAY be computed using the algorithm described in section
   3.7 of [RFC7844].  If this is not possible, the randomized host name
   SHOULD be constructed by simply picking a 48 bit random number
   meeting the Randomness Requirements for Security expressed in
   [RFC4075], and then use the hexadecimal representation of this number
   as the obfuscated host name.

4.2.  Instance Discovery Key

   The obfuscation and de-obfuscation of instance names is controlled by
   the Instance Discovery Key.  Each device publishing a service
   instance configures an Instance Discovery Key associated with the
   service instance.

   The Instance Key SHOULD be at least 16 bytes long (128 bits).  Its
   content SHOULD meet the Randomness Requirements for Security
   expressed in [RFC4075].

4.3.  Composing Obfuscated Instance Names

   The obfuscated instance name is composed of two components, a seed
   and a hash, encoded in BASE64 ([RFC2045] section 6.8) and separated
   by a dot:

      instance_name = <base64_seed> "." <base64_hash>

   The seed is derived algorithmically from the randomized host name.
   If the randomized name changes, new instance names SHOULD be computed
   and the corresponding records SHOULD be published in order to meet
   the requirement defined in Section 3.8.

   The complete instance name MUST be generated using the following
   process:





Huitema & Kaiser        Expires December 2, 2016               [Page 14]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


      long_seed = HASH(randomized_host_name)
      seed = first 12 bytes of long_seed
      long_hash = HASH(seed | instance_discovery_key )
      instance_hash = first 12 bytes of long_hash
      instance_name = BASE64(seed) "." BASE64(instance_hash)

   In this formula, HASH SHOULD be the function SHA256 defined in
   [RFC4055], unless otherwise specified.  Implementers MAY eventually
   replace SHA256 with a stronger algorithm.

   The algorithm produces seeds and hash that are encoded as 16 BASE64
   characters.  The resulting instance name is 33 characters long, which
   fits within the 63 characters limit defined in [RFC6763].

4.4.  De-Obfuscation of Instance Names

   De-obfuscation of instance names assumes that authorized nodes are
   provisioned with three elements for each discoverable instance:

   o  the de-obfuscated instance name,

   o  a copy of the instance_discovery_key,

   o  optionally, the identifier of the HASH function used by the
      publisher.

   A given node may be provisioned do discover many instances.  For
   example, Alice's phone may know about Alice's laptop and Alice's
   desktop.  It might also know of Bob's laptop, if Alice and Bob have
   agreed to share such information.

   To de-obfuscate the instance names, nodes performing discovery should
   obtain the list of PTR records published for the service and domain
   being searched and then do the following:

   o  Test whether the instance name contains the base64 encoding of a
      seed and hash as defined in Section 4.3.  If it is not in that
      form, the name is not considered obfuscated.

   o  Retrieve the binary seed and hash from the base64 encoding.

   o  For each known instance discovery key, compute whether the hash of
      the seed and key, and compare it to the published hash.

   o  If there is a hash, the de-obfuscated name of the instance is the
      de-obfuscated name associated with the matching instance discovery
      key




Huitema & Kaiser        Expires December 2, 2016               [Page 15]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


5.  Considerations on the pairing requirement

   A problem with the mitigation techniques described so far is the need
   for a pairing.  When service instance keys are used, each service
   instance needs a separate key, which in turn has to be transmitted to
   all devices that should be able to discover the corresponding service
   instance.  This is disadvantageous in two ways.  On the one hand, it
   demands a pairing for each service instance; on the other hand it
   makes it impossible to discover new service instances without prior
   pairing.  Both problems can be mitigated by using the method
   described in the following.

   Privacy Preserving Service Discovery can be divided into three
   independent layers: Device Pairing, Directory Discovery, and Service
   Querying [KW14b].

5.1.  Device Pairing

   Device pairing is a must for privacy preserving service discovery, as
   devices need means for (private) mutual authentication.  To this end,
   each user has a public/private key pair.  The purpose of device
   pairing is both obtaining the public key of a "friend" and verifying
   the authenticity of this key.

   Since several other applications apart from service discovery also
   need a pairing that allows later authentication of another user, we
   propose to outsource device pairing to a dedicated component, e.g.  a
   device pairing daemon [see Chapter 5 of my thesis].

   Obtaining and verifying this key, can be achieved by different means.
   For obtaining the keys, we can either leverage an existing PKI, e.g.
   the PGP web of trust, or generate our own key pairs (and exchange
   them right before verifying).  For authenticating the keys, which
   boils down to comparing fingerprints on an off-channel, we
   distinguish between means that demand users to be in close proximity
   of each other, and means where users do not have to meet in person.
   The former can e.g. be realized by verifying a fingerprint leveraging
   QR-Codes, the latter by reading a fingerprint during a phone call or
   using the socialist millionaires protocol.

   There are two kinds of pairings: (1) inter-user pairing is a pairing
   between devices of "friends".  Since this has to be done manually,
   e.g. by the means described above, it is important to limit it to
   once per pair of friends.  (2) intra-user pairing is a pairing of
   devices of the same user.  It can be performed without any
   configuration by a meta-service (pairing data synchronization
   service) in a trusted (home) network.




Huitema & Kaiser        Expires December 2, 2016               [Page 16]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


5.2.  Directory Discovery

   The set of devices that offer service instances can be seen as a
   distributed service directory.  When a user wants to discover
   services, she first discovers the part of the service directory she
   is authorized to use, meaning the devices of her online friends.
   This is done using another meta service (private service directory
   service, PSDS) whose task it is to handle queries for actual
   services.

   In order to be privacy preserving, the PSDS has to transmit the
   necessary data over an encrypted and mutually authenticated channel.
   To retrieve information (PTR, TXT, SRV) about private services
   offered by friends, first these friends' PSDSes have to be discovered
   (directory discovery), and secondly, the users have to use private
   mutual authentication guaranteeing the privacy of both parties.

   For the discovery part, there is need for a service instance name
   that allows authorized friends to efficiently determine whether the
   service instance is meant for them or not.  Further, this instance
   name should not be traceable and be updated according to Section 3.8.
   To generate this instance name, we currently use hash(public_key ||
   time stamp).  This has two disadvantages: Everyone knowing of the
   public_key can trace the user (which is especially a problem when
   using a PKI), and it is dependent on time stamps, calling for hash
   table recalculations each time the time stamp runs out and is prone
   to time skew problems.  The first problem can be mitigated using a
   shared secret exchanged during pairing and renewing this secret after
   each connection.  (It really depends on what level of privacy is
   longed for; if we want to grant untraceability, we need unlinkable
   service instance names.  There is a paper on that matter by Pang et
   al.; I also did some research on making this more efficient but did
   not find a solution yet.)  Replay is no problem, as the following
   private mutual authentication will only work if both parties are who
   they claim to be; and neither party will disclose the identity to an
   imposter.

   A simple way for private mutual authentication between Alice and Bob
   can performed in a three way handshake as follows.  After Alice has
   discovered Bob's PSDS, she contacts Bob's PSDS by (simplified
   explanation)

   o  sending to Bob: g^a, prvSID_A=hash(secret||timestamp) the prvSID
      lets Bob know that the message is a session start request most
      likely sent from Alice.

   o  Bob answers: g^a, enc_A(sig_B(g^{ab})) At this point the DH key
      exchange is complete.  Further, Bob can verify Alice's identity



Huitema & Kaiser        Expires December 2, 2016               [Page 17]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


      (if he really is Bob) by decrypting the corresponding block and
      checking Alice's signature.

   o  Alice answers: enc_B(sig_A(g^{ab})) Now Alice can verify Bob (is
      she really if Alice) decrypting the corresponding block and
      checking Bob's signature.

5.3.  Service Querying

   Service Querying: The PSDS is offered by a small DNS server running
   on each user's device; this DNS server can be queried for the service
   instances offered by the corresponding user.  Messages sent during
   the process of service querying are encrypted using authenticated
   encryption with keys derived from g^{ab}, the DH key exchanged during
   directory discovery.

5.4.  Summarizing Thoughts

   This solution mitigates both afore mentioned problems as it reduces
   pairing to one pairing per pair of friends and allows to offer
   services in a privacy preserving way whose existence was unknown at
   the time of pairing.  This grants an almost zeroconf user experience.
   An other disadvantage of the 1-stage approach it that either it needs
   a service instance key per service instance and user; or it uses the
   same key for all users.  The former is more privacy preserving but
   has the huge disadvantage of demanding a huge load of multicast
   messages, which are inefficient anyway.  The latter makes friend
   revocations very complicated -> repairing for each friend that should
   still be able to de-obfuscate the instance.  (It would be possible to
   use keys for groups of friends, finding a compromise between these
   two extremes.)

6.  Security Considerations

   This document specifies a method to protect the privacy of service
   publishing nodes.  This is especially useful when operating in a
   public space.  Obfuscating the identity of the publishing nodes
   prevents some forms of "targeting" of high value nodes.

   Obfuscating the identity of the publishing nodes does not provide any
   form of access control.  It will not prevent attackers from trying to
   access the services.

   The cost of the de-obfuscation algorithm scales as the product of the
   number of authorized publishers known by the client, times the number
   of obfuscated services published in the searched name domain.
   Attackers could potentially publish a large number of bogus instances
   of a service, forcing a high computation cost on discovery clients.



Huitema & Kaiser        Expires December 2, 2016               [Page 18]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   While this potential denial of service attack is concerning, we note
   that this is merely an aggravation of a flooding attacks against DNS-
   SD.

7.  IANA Considerations

   This draft does not require any IANA action.

8.  Acknowledgments

   This draft results from initial discussions with Dave Thaler.

9.  References

9.1.  Normative References

   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, DOI 10.17487/RFC2045, November 1996,
              <http://www.rfc-editor.org/info/rfc2045>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC4055]  Schaad, J., Kaliski, B., and R. Housley, "Additional
              Algorithms and Identifiers for RSA Cryptography for use in
              the Internet X.509 Public Key Infrastructure Certificate
              and Certificate Revocation List (CRL) Profile", RFC 4055,
              DOI 10.17487/RFC4055, June 2005,
              <http://www.rfc-editor.org/info/rfc4055>.

   [RFC4075]  Kalusivalingam, V., "Simple Network Time Protocol (SNTP)
              Configuration Option for DHCPv6", RFC 4075,
              DOI 10.17487/RFC4075, May 2005,
              <http://www.rfc-editor.org/info/rfc4075>.

   [RFC6763]  Cheshire, S. and M. Krochmal, "DNS-Based Service
              Discovery", RFC 6763, DOI 10.17487/RFC6763, February 2013,
              <http://www.rfc-editor.org/info/rfc6763>.

9.2.  Informative References

   [I-D.ietf-dprive-dnsodtls]
              Reddy, T., Wing, D., and P. Patil, "DNS over DTLS
              (DNSoD)", draft-ietf-dprive-dnsodtls-06 (work in
              progress), April 2016.



Huitema & Kaiser        Expires December 2, 2016               [Page 19]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   [I-D.ietf-intarea-hostname-practice]
              Huitema, C., Thaler, D., and R. Winter, "Current Hostname
              Practice Considered Harmful", draft-ietf-intarea-hostname-
              practice-02 (work in progress), May 2016.

   [KW14a]    Kaiser, D. and M. Waldvogel, "Adding Privacy to Multicast
              DNS Service Discovery", DOI 10.1109/TrustCom.2014.107,
              2014, <http://ieeexplore.ieee.org/xpl/
              articleDetails.jsp?arnumber=7011331>.

   [KW14b]    Kaiser, D. and M. Waldvogel, "Efficient Privacy Preserving
              Multicast DNS Service Discovery",
              DOI 10.1109/HPCC.2014.141, 2014,
              <http://ieeexplore.ieee.org/xpl/
              articleDetails.jsp?arnumber=7056899>.

   [RFC1033]  Lottor, M., "Domain Administrators Operations Guide",
              RFC 1033, DOI 10.17487/RFC1033, November 1987,
              <http://www.rfc-editor.org/info/rfc1033>.

   [RFC1034]  Mockapetris, P., "Domain names - concepts and facilities",
              STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987,
              <http://www.rfc-editor.org/info/rfc1034>.

   [RFC1035]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, RFC 1035, DOI 10.17487/RFC1035,
              November 1987, <http://www.rfc-editor.org/info/rfc1035>.

   [RFC2782]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
              specifying the location of services (DNS SRV)", RFC 2782,
              DOI 10.17487/RFC2782, February 2000,
              <http://www.rfc-editor.org/info/rfc2782>.

   [RFC6762]  Cheshire, S. and M. Krochmal, "Multicast DNS", RFC 6762,
              DOI 10.17487/RFC6762, February 2013,
              <http://www.rfc-editor.org/info/rfc6762>.

   [RFC7626]  Bortzmeyer, S., "DNS Privacy Considerations", RFC 7626,
              DOI 10.17487/RFC7626, August 2015,
              <http://www.rfc-editor.org/info/rfc7626>.

   [RFC7844]  Huitema, C., Mrugalski, T., and S. Krishnan, "Anonymity
              Profiles for DHCP Clients", RFC 7844,
              DOI 10.17487/RFC7844, May 2016,
              <http://www.rfc-editor.org/info/rfc7844>.






Huitema & Kaiser        Expires December 2, 2016               [Page 20]

Internet-Draft          DNS-SD Privacy Extensions               May 2016


   [RFC7858]  Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,
              and P. Hoffman, "Specification for DNS over Transport
              Layer Security (TLS)", RFC 7858, DOI 10.17487/RFC7858, May
              2016, <http://www.rfc-editor.org/info/rfc7858>.

Authors' Addresses

   Christian Huitema
   Microsoft
   Redmond, WA  98052
   U.S.A.

   Email: huitema@microsoft.com


   Daniel Kaiser
   University of Konstanz
   Konstanz  78457
   Germany

   Email: daniel.kaiser@uni-konstanz.de






























Huitema & Kaiser        Expires December 2, 2016               [Page 21]

