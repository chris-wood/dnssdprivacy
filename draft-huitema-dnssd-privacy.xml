<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc1033 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1033.xml'>
<!ENTITY rfc1034 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml'>
<!ENTITY rfc1035 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml'>
<!ENTITY rfc2045 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2045.xml'>
<!ENTITY rfc2119 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc2782 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml'>
<!ENTITY rfc4055 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml'>
<!ENTITY rfc4075 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4075.xml'>
<!ENTITY rfc4279 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4279.xml'>
<!ENTITY rfc6762 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml'>
<!ENTITY rfc6763 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml'>
<!ENTITY rfc7626 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7626.xml'>
<!ENTITY rfc7844 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7844.xml'>
<!ENTITY rfc7858 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml'>

<!ENTITY I-D.ietf-intarea-hostname-practice PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-intarea-hostname-practice.xml"> 
<!ENTITY I-D.ietf-dprive-dnsodtls PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dprive-dnsodtls.xml">
<!ENTITY I-D.ietf-tls-tls13 PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-tls13.xml">

<!ENTITY kw14a PUBLIC ''
   "references/reference.kw14a.xml">
<!ENTITY kw14b PUBLIC ''
   "references/reference.kw14b.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="std" 
     docName="draft-huitema-dnssd-privacy-01.txt"
     ipr="trust200902">

<front>
    <title abbrev="DNS-SD Privacy Extensions">
      Privacy Extensions for DNS-SD
    </title>

   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <street> </street>
          <city>Redmond</city>
          <code>98052</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@microsoft.com</email>
      </address>
    </author>

   <author fullname="Daniel Kaiser" initials="D." surname="Kaiser">
     <organization>University of Konstanz</organization>
      <address>
        <postal>
          <street> </street>
          <city>Konstanz</city>
          <code>78457</code>
          <region></region>
          <country>Germany</country>
        </postal>
        <email>daniel.kaiser@uni-konstanz.de</email>
      </address>
    </author>

    <date year="2016" />

    <abstract>
        <t> 
DNS-SD allows discovery of services published in DNS or MDNS. The publication
normally disclose information about the device publishing the services.
There are use cases where devices want to communicate without disclosing
their identity, for example two mobile devices visiting the same
hotspot.
</t>
<t>
We propose to solve this problem by defining a "Private Discovery Service",
which is a version of DNS-SD running over TLS. Nodes that provide private
services will run the Private Discovery Service, and publish its presence
in DNS-SD using special formats to protect their privacy. Nodes will be
authorized to access the services by a pairing system, resulting in
the establishment of shared secrets. Peered nodes
will discover the Private Discovery Services of their peers, and use TLS
connections authenticated by a shared secret to retrieve information
about the actual services.
</t>
    </abstract>
</front>

<middle>
<section title="Introduction">
<t>
DNS-SD <xref target="RFC6763" /> enables distribution and discovery in local networks 
without configuration. It is very convenient for users, but it requires the public exposure 
of the offering and requesting identities along with information about the offered and 
requested services.  Some of the information published by the 
announcements can be very revealing. These privacy issues and potential
solutions are discussed in <xref target="KW14a" /> 
and <xref target="KW14b" />.
</t>
<t>
There are cases when nodes connected to a network want to provide
or consume services without exposing their identity to the other
parties connected to the same network. Consider for example a
traveler wanting to upload pictures from a phone to a laptop
when connected to the Wi-Fi network of an Internet cafe, or
two travelers who want to share files between their laptops
when waiting for their plane in an airport lounge.
</t>
<t>
We expect that these exchanges will start with a discovery 
procedure using DNS-SD <xref target="RFC6763" />. One of the devices
will publish the availability of a service, such as a picture library
or a file store in our examples. The user of the other device will
discover this service, and then connect to it.
</t>
<t>
When analyzing these scenarios in <xref target="analysis"/>, we find that
the DNS-SD messages leak identifying information such as instance name,
host name or service properties. We review the design constraint of a solution
in <xref target="design"/>, and describe the proposed solution in
<xref target="solution"/>.
</t>
<section title="Requirements">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref target="RFC2119" />.
</t>
</section>
</section>

<section title="Privacy implications of DNS-SD" anchor="analysis">
<t>
DNS-Based Service Discovery (DNS-SD) is defined in <xref target="RFC6763" />.
It allows nodes to publish the availability of an instance of a service by
inserting specific records in the DNS (<xref target="RFC1033"/>,
<xref target="RFC1034"/>, <xref target="RFC1035"/>) or by publishing
these records locally using
multicast DNS (mDNS) <xref target="RFC6762"/>.
Available services are described using three types of records:
</t>
<t>
<list style="hanging">
<t hangText="PTR Record:">Associates a service type in the domain with
an "instance" name of this service type.
</t>
<t hangText="SRV Record:">Provides the node name, port number, priority and
weight associated with the service instance, in conformance with <xref target="RFC2782" />.
</t>
<t hangText="TXT Record:">Provides a set of attribute-value pairs describing
specific properties of the service instance.
</t>
</list>
</t>
<t>
In the remaining subsections, we will review the privacy issues related to publishing
instance names, node names, service attributes and other data, as well as review 
the implications of using the discovery service as a client.
</t>

<section title="Privacy implication of publishing Service Instance Names" anchor="instanceLeak" >
<t>
In the first phase of discovery, the client obtains all
the PTR records associated with a service type in a given naming domain.
Each PTR record contains a Service Instance Name defined in Section 4 of <xref target="RFC6763" />:
</t>

<t>
<figure>
<artwork>
  Service Instance Name = &lt;Instance&gt; . &lt;Service&gt; . &lt;Domain&gt;
</artwork>
</figure>
</t>

<t>
The &lt;Instance&gt; portion of the Service Instance Name is meant to convey
enough information for users of discovery clients to easily select the desired service instance.
Nodes that use DNS-SD over mDNS <xref target="RFC6762" /> in a mobile environment will rely on the specificity
of the instance name to identify the desired service instance.
In our example of users wanting to upload pictures to a laptop in an Internet Cafe, the list of 
available service instances may look like:
</t>
<t>
<figure>
<artwork>
Alice's Images         . _imageStore._tcp . local
Alice's Mobile Phone   . _presence._tcp   . local
Alice's Notebook       . _presence._tcp   . local
Bob's Notebook         . _presence._tcp   . local
Carol's Notebook       . _presence._tcp   . local
</artwork>
</figure>
</t>
<t>
Alice will see the list on her phone and understand intuitively that she should
pick the fist item. The discovery will "just work".
</t>
<t>
However, DNS-SD/mDNS will reveal to anybody that Alice is currently visiting the Internet Cafe.
It further discloses the fact that she uses two devices, shares an image store, 
and uses a chat application supporting the
_presence protocol on both of her devices. She might currently chat with Bob or Carol, 
as they are also using a _presence supporting chat application.
This information is not just available to devices actively browsing for and offering 
services, but to anybody passively listing to the network traffic.
</t>
</section>

<section title="Privacy implication of publishing node names">
<t>
The SRV records contain the DNS name of the node publishing the
service. Typical implementations construct this DNS name by
concatenating the "host name" of the node with the name of the 
local domain. The privacy implications of this
practice are reviewed in <xref target="I-D.ietf-intarea-hostname-practice" />.
Depending on naming practices, the host name is either a strong 
identifier of the device, or at a minimum a partial identifier.
It enables tracking of the device, and by extension of the device's owner.
</t>
</section>

<section title="Privacy implication of publishing service attributes">
<t>
The TXT records contain a set of attribute and value pairs characteristics of
the service implementation. These attributes reveal some information
about the devices that publishes the service. The amount of information
will vary widely with the particular service and its implementation:
</t>
<t>
<list style="symbols">
<t>
Some attributes like the paper size available in a printer, are the
same on many devices, and thus only provides limited information
to a tracker.
</t>
<t>
Attributes that have freeform values, such as the name of a directory,
may reveal much more information.
</t>
</list>
</t>
<t>
Combinations of attributes have more information power than specific attributes,
and can potentially be used for "fingerprinting" a specific device.
</t>

</section>

<section title="Device fingerprinting" anchor="serverFingerprint">
<t>
The combination of information published in DNS-SD has the potential to
provide a "fingerprint" of a specific device. Such information includes: 
</t>
<t>
<list style="symbols">
<t>
The list of services published by the device, which can be retrieved because the
SRV records will point to the same host name.
</t>
<t>
The specific attributes describing these services.
</t>
<t>
The port numbers used by the services.
</t>
<t>
The values of the priority and weight attributes in the SRV records.
</t>
</list>
</t>
<t>
This combination of services and attribute will often be sufficient to identify
the version of the software running on a device. If a device publishes
many services with rich sets of attributes, the combination may be
sufficient to identify the specific device. 
</t>
<t>
There is however an argument that devices providing services can be discovered
by observing the local traffic, because different services have different traffic 
patterns. The observation could in many cases also reveal some specificities
of the service's implementation. Even if the traffic is encrypted, the size
and the timing of packets may be sufficient to reveal that information. This
argument can be used to assess the priority of, for example, protecting the 
fact that a device publishes a particular service. However, we may assume that the 
developers of sensitive services will use counter-measures to defeat such
traffic analysis.
</t>
</section>

<section title="Privacy implication of discovering services" anchor="clientPrivacy" >
<t>
The consumers of services engage in discovery, and in doing so do 
reveal some information such as the list of services that they
are interested in and the domains in which they are looking for the
services. When the clients select specific instances of services,
they reveal their preference for these instances. This can be benign if
the service type is very common, but it could be more problematic
for sensitive services, such as for example some private messaging services.
</t>
<t>
One way to protect clients would be to somehow encrypt the requested service types.
Of course, just as we noted in <xref target="serverFingerprint"/>, traffic
analysis can often reveal the service. 
</t>
</section>
</section>

<section title="Limits of a simple design" anchor="towards" >
<t>
We tried first a simple design for mitigating the issues outlined in <xref target="analysis" />. 
The basic idea is to advertise obfuscated names, so as to not reveal the particularities
of the service providers. This design is tempting, because it only requires minimal
changes in the DNS-SD processing. However, as we will see in the following subsections,
it has two important drawbacks:
</t>
<t>
<list style="symbols">
<t>
The simple design leads to UI issues, because users of unmodified DNS-SD agents will see
a mix of clear text names and obfuscated names, which is unpleasant; 
</t>
<t>
The simple design either requires having a shared key between all "authorized users" of a 
service, which implies substandard key management practices, or publishing as many instances
of a service as there are authorized users, which leads to the scaling issues  
discussed in <xref target="scalingIssues"/>.
</t>
</list>
</t>
<t>
Both issues are mitigated by the two-stage design presented in <xref target="design" />. The following
subsections detail the simple design, and its drawbacks.
</t>
<section title="Obfuscated instance names" anchor="obfuscatedInstanceName" >
<t>
The privacy issues described in <xref target="instanceLeak"/> 
can be solved by obfuscating the instance names. Instead
of a user friendly description of the instance,
the nodes will publish a random looking string of characters.
To prevent tracking over time and location, different string
values should be used at different locations, or at different times.
</t>
<t>
Authorized parties should be able to "de-obfuscate" the names,
while non-authorized third parties will not be. For example,
if both Alice notebook and Bob's laptop use an obfuscation process, 
the list of available services should appear differently 
to them and to third parties. Alice's phone will be able to
de-obfuscate the name of Alice's notebook, but not that of 
Bob's laptop. Bob's phone will do the opposite. Carol will do
neither.
</t>
<t>
Alice will see something like:
</t>
<t>
<figure>
<artwork>
QwertyUiopAsdfghjk (Alice's Images)       . _imageStore._tcp . local
GobbeldygookBlaBla (Alice's Mobile Phone) . _presence._tcp   . local
MNbvCxzLkjhGfdEdhg (Alice's Notebook)     . _presence._tcp   . local
Abracadabragooklybok (Bob's Notebook)     . _presence._tcp   . local
Carol's Notebook                          . _presence._tcp   . local
</artwork>
</figure>
</t>
<t>
Bob will see:
</t>
<t>
<figure>
<artwork>
QwertyUiopAsdfghjk                    . _imageStore._tcp . local
GobbeldygookBlaBla                    . _presence._tcp   . local
MNbvCxzLkjhGfdEdhg                    . _presence._tcp   . local
Abracadabragooklybok (Bob's Notebook) . _presence._tcp   . local
Carol's Notebook                      . _presence._tcp   . local
</artwork>
</figure>
</t>
<t>
Carol will see:
</t>
<t>
<figure>
<artwork>
QwertyUiopAsdfghjk   . _imageStore._tcp . local
GobbeldygookBlaBla   . _presence._tcp   . local
MNbvCxzLkjhGfdEdhg   . _presence._tcp   . local
Abracadabragooklybok . _presence._tcp   . local
Carol's Notebook     . _presence._tcp   . local
</artwork>
</figure>
</t>
<t>
In that example, Alice, Bob and Carol will be able to select the
appropriate instance. It would probably be preferable to filter out the
obfuscated instance names, to avoid confusing the user. In our example, Alice 
and Bob have updated their software to understand obfuscation, and they
could easily filter out the obfuscated strings that they do not like.
But Carol is not using this system, and we could argue that her experience 
is suboptimal.
</t>
<t>
The suboptimal experience with unmodified software could be avoided if
the obfuscated service records were published using different service names,
or using different domain names. This would of course make management a bit
more complex, and is thus debatable.
</t>
</section>


<section title="Names of obfuscated services">

<t>
Instead of publishing the actual service name in the SRV records,
nodes could publish a randomized name. There are two plausible reasons
for doing that:
</t>
<t>
<list style="symbols">
<t>
Having a different service name for privacy enhanced services will ensure
that hosts that are not privacy aware are not puzzled by obfuscated service names.
</t>
<t>
Using obfuscated service names prevents third parties from discovering
which service a particular host is providing or consuming.
</t>
</list>
</t>
<t>
The first requirement can be met with a simple modification of an existing 
name. For example, instead of publishing:
</t>
<t>
<figure>
<artwork>
QwertyUiopAsdfghjk . _imageStore._tcp . local
GobbeldygookBlaBla . _presence._tcp   . local
</artwork>
</figure>
</t>
<t>
Alice could publish some kind of "translation" of the service name, such as:
</t>
<t>
<figure>
<artwork>
QwertyUiopAsdfghjk . _vzntrFgber._tcp . local
GobbeldygookBlaBla . _cerfrapr._tcp   . local
</artwork>
</figure>
</t>
<t>
The previous examples use rot13 translation. It does not provide any 
particular privacy, but it does ensure that obfuscated services are
named differently from clear text services.
</t>
<t>
Making the service name actually private would require some actual encryption.
The main problem with such solutions is that the client needs to know the
service name in order to compose the DNS-SD query for services. There are several 
options:
</t>
<t>
<list style="symbols">
<t>
The service name is chosen by the client. For example, the client could 
encrypt the original service 
name and a nonce with a key shared between client and server. Upon receiving
the queries, the server would attempt to decrypt the service name. If that 
succeeds, the server would respond with PTR records created on the fly for
the new service name.
</t>
<t>
The service name is chosen by the server and cannot be predicted in advance by
the client. For example, the server could encrypt a nonce and
the original service name. The client retrieves such services by doing
a wild card query, then attempting to decrypt the received responses.
</t>
<t>
The service name is chosen by the server in a way that can be predicted in advance by
the client. For example, the server could encrypt some version of the data and time and
the original service name. The data and time are encoded with a coarse precision, enabling
the client to predict the value that the server is using, and to send the corresponding
queries.
</t>
</list>
</t>
<t>
None of these solutions is very attractive. Creating records on the fly is a burden
for the server. If clients must use wildcard queries, they will need to process
lots of irrelevant data. If clients need to predict different instance names for
each potential server, they will end up sending batches of queries with many
different names. All of these solutions appear like big departures from the 
simplicity and robustness of the DNS-SD design.
</t>
<t>
Given the relatively low priority of hiding the service name and the complexity
of the potential solutions, we are not recommending any particular
protection for the instance names.
</t>
</section>


<section title="Scaling issues with obfuscation" anchor="scalingIssues" >
<t>
In <xref target="obfuscatedInstanceName" />, we assumed that each advertised
record contains a name obfuscated with a shared key. This approach is easy
to understand, but it contains the hidden assumption. Let look at one of our 
examples:
</t>
<t>
<figure>
<artwork>
Abracadabragooklybok (Bob's Notebook) . _presence._tcp   . local
</artwork>
</figure>
</t>
<t>
We only see there one record for Bob's Notebook, obfuscated using 
the unique shared secret associated with Bob's Notebook. That means that
every device paired with Bob's Notebook will have a copy of that shared secret.
We could of course do that, but there are known issues with having a secret 
shared with multiple entities:
</t>
<t>
<list style="symbols">
<t>
If for some reason the secret needs to be changed, every paired
device will need a copy of the new secret before they can participate
again in discovery;
</t>
<t>
If one of the previous pairing becomes invalid, the only way
to block the corresponding devices from discovery is to change the
secret for all other devices.
</t>
</list>
</t>
<t>
Key management becomes much easier if it is strictly pair-wise. Two
paired devices, or to pairs of users, can simply renew their
pairing and get a new secret. If a device ceases to be trusted, 
the pairing data and the corresponding secret can just be 
deleted and forgotten. But then, we have a scaling issue.
Let's assume that:
</t>
<t>
<list style="symbols">
<t>
Each device maintains an average of N pairing
</t>
<t>
There are on average M devices present during discovery
</t>
</list>
</t>
<t>
In the single key scenario, after issuing a broadcast query, the querier 
will receive a series of responses, each of which may well be obfuscated 
with a different key. If the receiver has N pre-existing pairing and 
receives M obfuscated responses, the cost will scale as O(M*N), i.e. try 
all N pairing keys for each of the M responses to see what matches. But
if the keys are specific to each pair of devices, the obfuscation becomes 
complicated. When receiving a request, the publisher does not know which 
of its N keys the querier can decrypt. One simple solution would be to 
send N responses, but then the load on the querier will scale as O(M*N^2).
That can go out of hand very quickly.
</t>
<t>
To solve the scaling issue, we consider a two-stages solutions: use
an optimized discovery procedure to discover privacy-compatible devices;
and use point to point encrypted exchanges to privately discover
the available services.
</t>
</section>


</section>

<!-- CH: Comment
I kept the name that you have chosen, "Directory Discovery," but I find it confusing.
I would really like to name the service that we are creating "Private Discovery Service."
We are using DNS Service Discovery (DNS-SD) to discover the Private Discovery Service.
-->

<section title="Design of the DNS-SD Privacy Problem Mitigation" anchor="design" >
<t>
In this section, we present the design of a two stage solution that enables private
use of DNS-SD, without affecting existing users, and with better scalability than 
the simple solution presented in <xref target="towards" />. The solution is largely based
on the architecture proposed in <xref target="KW14b" />. It is based on the following 
components:
</t>
<t>
<list>
<t>
We assume the existence of a pairing system, described in <xref target="pairingDesign"/>, 
through which authorized peers can establish shared secrets;
</t>
<t>
We define a secure directory service through which other services can be advertised
in a private manner;
</t>
<t>
And, we design a specific way to publish the secure directory service using DNS-SD,
so that peers can discover their services without compromising their privacy.
</t>
</list>
</t>

<section title="Device Pairing" anchor="pairingDesign" >

<t>
  Our solution adds device pairing to DNS-SD and divides service discovery into two stages:
  Directory Discovery and Service Querying 
  These are independent with respect to means used for transmitting the necessary data.
  One possible setup is performing pairing via Bluetooth LE, Directory Discovery via obfuscated mDNS and
  Service Querying via TLS.
  Pairing has to provide Directory Discovery with means for mutual authentication, e.g. with an authenticated shared secret.
  Directory Discovery has to provide Service Querying with an authenticated connection to the desired service directory.
</t>

<t>
  Any private discovery solution needs to differentiate
  between authorized devices, which are allowed to get information about discoverable entities,
  and other devices, which should not be aware of the availability of private entities.
  The commonly used solution to this problem is establishing a  "device pairing".
  In our discovery scenarios, we envisage two kinds of pairings:
</t>

<t>
<list style="numbers">
<t>
inter-user pairing is a pairing between devices of "friends".
      Since this has to be done manually, e.g. by the means described above,
      it is important to limit it to once per pair of friends.
</t>
<t>
intra-user pairing
      is a pairing of devices of the same user. It can be performed
      without any configuration by a meta-service (pairing data synchronization service) in
      a trusted (home) network.
    </t>
</list>
</t>

<t>
  The result of the pairing will be a shared secret, and optionally
  mutually authenticated public keys added to a local web of trust.
  Public key technology has many advantages, but shared secrets are typically easier to
  handle on small devices.
  We offer both a simple pairing just exchanging a shared secret, and an authenticated pairing
  using public key technology.
</t>
<!-- CH-Comments:
I leave this as is, because we will have time to revisit it later, but I think
that the discussion here is a bit confusing. The private discovery service
should just assume the existence of a shared secret by pair of peers. The
pairing service can establish this secret in many ways, including of
course taking advantage of lready authenticated public keys. 
-->

<section title="Shared Secret">
<t>
  TODO: generation and transmission of the shared secret.

  When using Bluetooth LE or scanning a QR code as means of transmitting the shared secret,
  the probability of the secret getting stolen is reasonably low.
</t>
</section>


<section title="Secure Authenticated Pairing Channel">
<t>
  Optionally, authenticated DH can be used to exchange a mutually authenticated shared secret.
  
  TODO: protocol.

  Further, using DH to generate the shared secret has the advantage of both parties contributing to the shared secret (multiparty computation).
</t>
</section>


<section title="Public Authentication Keys">
  <t>
  The public/private key pair - if at all - is just used for the aforementioned authenticated DH to
  grant a mutually authenticated shared secret.
  Obtaining and verifying a friend's public key, can be achieved by different means.
  For obtaining the keys, we can either leverage an existing PKI, e.g. the PGP web of trust,
  or generate our own key pairs (and exchange them right before verifying).
  For authenticating the keys, which boils down to comparing fingerprints on an off-channel,
  we distinguish between means that demand users to be in close proximity of each other,
  and means where users do not have to meet in person.
  The former can e.g. be  realized by verifying a fingerprint leveraging QR-Codes,
  the latter by reading a fingerprint during a phone call or using the socialist millionaires protocol.
</t>
</section>

</section>


<section title="Private Service Directory Service" anchor="stage1Design">
<t>
The first stage of service discovery is directory discovery, i.e.
the discovery of the available "privacy compatible" devices.
The goal of that stage is to identify devices that share a pairing with the querier, and
are available locally. They could be discovered by querying for the
service "_psds._tls" using regular DNS-SD procedures, but the list of
discovered services will have to be filtered so only paired
devices are retained.
</t>
<t>
We have demonstrated in <xref target="scalingIssues" /> that 
simple obfuscation would require publishing as many records per
publisher as there are pairings, which ends up scaling as O(M*N^2)
in which M is the number of devices present and N is the number of
pairings per device. We can mitigate this problem by using a special
encoding of the instance name. Suppose that the publisher manages 
N pairings with the associated keys K1, K2, ... Kn. The instance
name will be set to an encoding of N "proofs" of the N keys,
where each proof is computed as function of the key and a nonce:
</t>
<t>
<list>
<t>
instance name = &lt;nonce&gt;&lt;F1&gt;&lt;F2&gt;..&lt;Fn&gt;
</t>
<t>
Fi = hash (nonce, Ki), where hash is a cryptographic hash function.
</t>
</list>
</t>
<t>
The querier can test the instance name by computing the same "proof" for
each of its own keys. Suppose that the receiver manages P pairings, with
the corresponding keys X1, X2, .. Xp. The receiver verification
procedure will be:
</t>
<t>
<figure>
<artwork>
   for each received instance name:
      retrieve nonce from instance name
      for (j = 1 to P)
         retrieve the key Xj of pairing number j
         compute F = hash(nonce, Xj)
         for (i=1 to N)
            retrieve the proof Fi
            if F is equal to Fi
               mark the pairing number j as available
</artwork>
</figure>
</t>
<t>
The procedure presented here requires on average O(M*N) iterations of the
hash function, which is the same scaling as the "shared secret" variant.
It requires O(M*N^2) comparison operations, but these are less onerous
than cryptographic operations.
Further, when setting the nonce to a timestamp, the Fi have to be
calculated only once per time interval.
</t>
<t>
The number of pairing proofs that can be encoded in a single record is
limited by the maximum size of a DNS label, which is 63 bytes. Since
this are characters and not pure binary values, nonce and proofs
will have to be encoded using BASE64 (<xref target="RFC2045" /> section 6.8),
resulting in at most 378 bits. The nonce should 
not be repeated, and the simplest way to achieve that is to set
the nonce to a 32 bit timestamp value. The remaining 346 bits could encode
up to 10 proofs of 32 bits each, which would be sufficient for many
practical scenarios. 
</t>
<t>
In practice, a 32 bit proof should be sufficient to
distinguish between available devices. However, there is clearly a risk
of collision. The Private Service Directory Service as described here will
find the available pairings, but it might also find a spurious number of 
"false positives." The chances of that happening are however quite small: 
less than 0.02% for a device managing 10 pairings and processing 10000
responses.
</t>

</section>

<section title="Directed Private Discovery" >
<t>
The Private Service Directory Service discovery allows
discovering a list of available paired devices, and verifying that either party knows the corresponding 
shared secret. At that point, the querier can engage in a series of
directed discoveries.
</t>
<t>
We have considered defining an ad-hoc protocol for the private discovery service, but 
found that  just using TLS would be much simpler. The Directed Private Discovery service 
is just a regular DNS-SD service, accessed over TLS, using the encapsulation of DNS over
TLS defined in <xref target="RFC7858" />. The main difference with simple DNS over TLS is
the need for authentication.
</t>
<t>
We assume that the pairing process has provided each pair of authorized client and server
with a shared secret. We can use that shared secret to provide mutual authentication of
clients and servers using "Pre Shared Key" authentication, as defined in <xref target="RFC4279" />
and incorporated in the latest version of TLS <xref target="I-D.ietf-tls-tls13" />.
</t>
<t>
One difficulty is the reliance on a key identifier in the protocol. 
For example, in TLS 1.3 the PSK extension is defined as:
</t>
<t>
<figure>
<artwork>
   opaque psk_identity&lt;0..2^16-1&gt;;

   struct {
       select (Role) {
           case client:
               psk_identity identities&lt;2..2^16-1&gt;;

           case server:
               uint16 selected_identity;
       }
   } PreSharedKeyExtension
</artwork>
</figure>
</t>
<t>
According to the protocol, the PSK identity is passed in clear text at the beginning of
the key exchange. This is logical, since server and clients need to identify the secret
that will be used to protect the connection. But if we used a static identifier for the
key, adversaries could use that identifier to track server and clients. The solution
is to use a time-varying identifier, constructed exactly like the "hint" described in
<xref target="stage1Design" />, by concatenating a nonce and the hash of the nonce with
the shared secret.
</t>


<section title="A note on Private DNS services" >
<t>
Our solution uses a variant of the DNS over TLS  protocol 
<xref target="RFC7858" /> defined by the DNS Private Exchange working group
(DPRIVE). DPRIVE is also working on an UDP variant, 
DNS over DTLS <xref target="I-D.ietf-dprive-dnsodtls" />, which
would also be a candidate.
</t>
<t>
DPRIVE and Private Discovery solve however two somewhat different
problems. DPRIVE is concerned with the confidentiality to DNS transactions, 
addressing the problems outlined in <xref target="RFC7626" />. However,
DPRIVE does not address the confidentiality or privacy issues with
publication of services, and is not a direct solution to DNS-SD privacy:
</t>
<t>
<list style="symbols" >
<t>
Discovery queries are scoped by the domain name within which services
are published. As nodes move and visit arbitrary networks, there
is no guarantee that the domain services for these networks
will be accessible using DNS over TLS or DNS over DTLS.
</t>
<t>
Information placed in the DNS is considered public. Even if
the server does support DNS over TLS, third parties will 
still be able to discover the content of PTR, SRV and TXT
records.
</t>
<t>
Neither DNS over TLS nor DNS over DTLS applies to MDNS.
</t>
</list>
</t>
<t>
In contrast, we propose using mutual authentication of the client and server
as part of the TLS solution, to ensure that only authorized parties learn
the presence of a service.
</t>
</section>


 </section>



<section title="Randomized host names" >
<t>
Instead of publishing their actual name in the SRV records, nodes 
could publish a randomized name. That is the solution argued for
in <xref target="I-D.ietf-intarea-hostname-practice" />.
</t>
<t>
Randomized host names will prevent some of the tracking.
Host names are typically not visible by the users, and
randomizing host names will probably not cause much
usability issues.
</t>
</section>


<section title="Timing of obfuscation and randomization" anchor="timing" >
<t>
It is important that the obfuscation of instance names is performed at the right time,
and that the obfuscated names change in synchrony with other identifiers,
such as MAC Addresses, IP Addresses or host names.
If the randomized host name changed
but the instance name remained constant, an adversary would have no difficulty
linking the old and new host names. Similarly, if IP or MAC addresses changed but 
host names remained constant, the adversary could link the new addresses to the
old ones using the published name.
</t>
<t>
The problem is handled in <xref target="I-D.ietf-intarea-hostname-practice" />, 
which recommends to pick a new random host name at the time of connecting to 
a new network. The instance names should be obfuscated at the same time,
or maybe use the randomized host name as input in the randomization
process.
</t>

</section>


</section>

<section title="Privacy extensions for DNS-SD" anchor="solution" >
<t>
The proposed solution uses the following components:
</t>
<t>
<list style="symbols">
<t>
The host names are randomized to prevent tracking.
</t>
<t>
Nodes provide an Instance Discovery Key to other nodes authorized to discover the service instance.
</t>
<t>
The Instance Discovery Key is combined with a random seed to obfuscate the instance names.
</t>
<t>
Nodes engaged in discovery attempt to de-obfuscate the instance names using the set of Instance Discovery Keys that they know about.
</t>
</list>
</t>
<t>
These components are detailed in the following subsections.
</t>
<section title="Randomized Host Name" >
<t>
Nodes publishing services with DNS-SD and concerned about their privacy MUST
use a randomized host name. The randomized name MUST be changed when
network connectivity changes, to avid the correlation issues described in
<xref target="timing" />. The randomized host name MUST be used in
the SRV records describing the service instance, and the corresponding 
A or AAAA records MUST be made available through DNS or MDNS, within the
same scope as the PTR, SRV and TXT records used by DNS-SD.
</t>
<t>
If the link-layer address of the network connection is properly obfuscated 
(e.g. using MAC Address Randomization), 
The Randomized Host Name MAY be computed using the algorithm described
in section 3.7 of <xref target="RFC7844" />. 
If this is not possible, the randomized host name SHOULD be constructed by simply
picking a 48 bit random number meeting the 
Randomness Requirements for Security expressed in <xref target="RFC4075" />,
and then use the hexadecimal representation of this number as the
obfuscated host name.
</t>
</section>

<section title="Instance Discovery Key" >
<t>
The obfuscation and de-obfuscation of instance names is controlled by the Instance Discovery Key. 
Each device publishing a service instance configures an Instance Discovery Key associated with
the service instance.
</t>
<t>
The Instance Key SHOULD be at least 16 bytes long (128 bits). Its content SHOULD meet the 
Randomness Requirements for Security expressed in <xref target="RFC4075" />.
</t>
</section>

<section title="Composing Obfuscated Instance Names" anchor="obfuscation" >
<t>
The obfuscated instance name is composed of two components,
a seed and a hash, encoded in BASE64 (<xref target="RFC2045" /> section 6.8)
and separated by a dot:
</t>
<t>
<figure>
<artwork>
   instance_name = &lt;base64_seed> "." &lt;base64_hash>
</artwork>
</figure>
</t>
<t>
The seed is derived algorithmically from the randomized host name. 
If the randomized name changes, new instance names SHOULD be computed
and the corresponding records SHOULD be published 
in order to meet the requirement defined in <xref target="timing" />.
</t>
<t>
The complete instance name MUST be generated using the following process:
</t>
<t>
<figure>
<artwork>
   long_seed = HASH(randomized_host_name)
   seed = first 12 bytes of long_seed
   long_hash = HASH(seed | instance_discovery_key )
   instance_hash = first 12 bytes of long_hash 
   instance_name = BASE64(seed) "." BASE64(instance_hash) 
</artwork>
</figure>
</t>
<t>
In this formula, HASH SHOULD be the function SHA256 
defined in <xref target="RFC4055"/>, unless otherwise specified. 
Implementers MAY eventually replace SHA256 with a stronger algorithm.
</t>
<t>
The algorithm produces seeds and hash that are encoded as 16 BASE64 characters.
The resulting instance name is 33 characters long, which fits
within the 63 characters limit defined in
<xref target="RFC6763"/>.
</t>
</section>

<section title="De-Obfuscation of Instance Names" >
<t>
De-obfuscation of instance names assumes that authorized nodes are provisioned with 
three elements for each discoverable instance:
</t>
<t>
<list style="symbols">
<t>
the de-obfuscated instance name,
</t>
<t>
a copy of the instance_discovery_key,
</t>
<t>
optionally, the identifier of the HASH function used by the publisher.
</t>
</list>
</t>
<t>
A given node may be provisioned do discover many instances. For example,
Alice's phone may know about Alice's laptop and Alice's desktop. It might
also know of Bob's laptop, if Alice and Bob have agreed to share such 
information.
</t>
<t>
To de-obfuscate the instance names, nodes performing discovery should 
obtain the list of PTR records published for the service and domain being 
searched and then do the following:
</t>
<t>
<list style="symbols">
<t>
Test whether the instance name contains the base64 encoding of a
seed and hash as defined in <xref target="obfuscation" />. If it
is not in that form, the name is not considered obfuscated.
</t>
<t>
Retrieve the binary seed and hash from the base64 encoding.
</t>
<t>
For each known instance discovery key, compute whether the
hash of the seed and key, and compare it to the published
hash.
</t>
<t>
If there is a hash, the de-obfuscated name of the instance
is the de-obfuscated name associated with the matching
instance discovery key
</t>
</list>
</t>

</section>

</section>


<section title="Security Considerations">
<t> 
This document specifies a method to protect the privacy of 
service publishing nodes. This is especially useful when operating
in a public space.
Obfuscating the identity of the publishing nodes prevents
some forms of "targeting" of high value nodes.
</t>
<t>
Obfuscating the identity of the publishing nodes does
not provide any form of access control. It will not prevent
attackers from trying to access the services.
</t>
<t>
The cost of the de-obfuscation algorithm scales as the product
of the number of authorized publishers known by the client,
times the number of obfuscated services published in the
searched name domain. Attackers could potentially publish
a large number of bogus instances of a service, forcing a
high computation cost on discovery clients. While this
potential denial of service attack is concerning, we note
that this is merely an aggravation of a flooding attacks
against DNS-SD. 
</t>
</section>

<section title="IANA Considerations" anchor="iana">
<t> 
This draft does not require any IANA action.
</t> 
</section>

<section title="Acknowledgments">
    <t>
This draft results from initial discussions with Dave Thaler.
    </t>
</section>
</middle>

<back>
<references title="Normative References">
       &rfc2045;
       &rfc2119;
       &rfc4055;
       &rfc4075;
       &rfc6763;
       &rfc4279;
</references>
<references title="Informative References">
       &rfc1033;
       &rfc1034;
       &rfc1035;
       &rfc2782;
       &rfc6762;
       &rfc7626;
       &rfc7844;
       &rfc7858;
       &I-D.ietf-intarea-hostname-practice;
       &I-D.ietf-dprive-dnsodtls;
       &I-D.ietf-tls-tls13;

<reference anchor="KW14a" target="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7011331">
  <front>
    <title>Adding Privacy to Multicast DNS Service Discovery</title>
    <author initials="D." surname="Kaiser" fullname="Daniel Kaiser">
      <organization/>
    </author>
    <author initials="M." surname="Waldvogel" fullname="Marcel Waldvogel">
      <organization/>
    </author>
    <date year="2014"/>
  </front>
  <seriesInfo name="DOI" value="10.1109/TrustCom.2014.107"/>
</reference>

<reference anchor="KW14b" target="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7056899">
  <front>
    <title>Efficient Privacy Preserving Multicast DNS Service Discovery</title>
    <author initials="D." surname="Kaiser" fullname="Daniel Kaiser">
      <organization/>
    </author>
    <author initials="M." surname="Waldvogel" fullname="Marcel Waldvogel">
      <organization/>
    </author>
    <date year="2014"/>
  </front>
  <seriesInfo name="DOI" value="10.1109/HPCC.2014.141"/>
</reference>


</references>  

</back>
</rfc>
